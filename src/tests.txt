// src/auth/auth.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { ConfigService } from '@nestjs/config';
import { UnauthorizedException, ConflictException } from '@nestjs/common';
import { AuthService } from './auth.service';
import { PrismaService } from '../prisma/prisma.service';
import { PasswordService } from './services/password.service';
import { TokenService } from './services/token.service';
import { RateLimitService } from './services/rate-limit.service';
import { MailService } from '../mail/mail.service';
import { SessionsService } from '../sessions/sessions.service';
import { UsersService } from '../users/users.service';

describe('AuthService', () => {
  let service: AuthService;
  let prismaService: PrismaService;
  let passwordService: PasswordService;
  let tokenService: TokenService;
  let rateLimitService: RateLimitService;
  let mailService: MailService;
  let sessionsService: SessionsService;
  let usersService: UsersService;

  const mockPrismaService = {
    user: {
      findUnique: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
    session: {
      create: jest.fn(),
      findFirst: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      deleteMany: jest.fn(),
    },
    verificationToken: {
      create: jest.fn(),
      findUnique: jest.fn(),
      delete: jest.fn(),
    },
    passwordResetToken: {
      create: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      deleteMany: jest.fn(),
    },
    $transaction: jest.fn(),
  };

  const mockPasswordService = {
    hashPassword: jest.fn(),
    verifyPassword: jest.fn(),
  };

  const mockTokenService = {
    generateAccessToken: jest.fn(),
    generateRefreshToken: jest.fn(),
    verifyRefreshToken: jest.fn(),
  };

  const mockRateLimitService = {
    checkLimit: jest.fn(),
  };

  const mockMailService = {
    sendEmailVerification: jest.fn(),
    sendPasswordReset: jest.fn(),
  };

  const mockSessionsService = {
    revokeSession: jest.fn(),
    revokeAllUserSessions: jest.fn(),
  };

  const mockUsersService = {
    findById: jest.fn(),
  };

  const mockConfigService = {
    get: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
        {
          provide: PasswordService,
          useValue: mockPasswordService,
        },
        {
          provide: TokenService,
          useValue: mockTokenService,
        },
        {
          provide: RateLimitService,
          useValue: mockRateLimitService,
        },
        {
          provide: MailService,
          useValue: mockMailService,
        },
        {
          provide: SessionsService,
          useValue: mockSessionsService,
        },
        {
          provide: UsersService,
          useValue: mockUsersService,
        },
        {
          provide: ConfigService,
          useValue: mockConfigService,
        },
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    prismaService = module.get<PrismaService>(PrismaService);
    passwordService = module.get<PasswordService>(PasswordService);
    tokenService = module.get<TokenService>(TokenService);
    rateLimitService = module.get<RateLimitService>(RateLimitService);
    mailService = module.get<MailService>(MailService);
    sessionsService = module.get<SessionsService>(SessionsService);
    usersService = module.get<UsersService>(UsersService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('register', () => {
    const registerDto = {
      email: 'test@example.com',
      password: 'password123',
      firstName: 'John',
      lastName: 'Doe',
    };

    const deviceInfo = {
      deviceId: 'device-123',
      ipAddress: '127.0.0.1',
      userAgent: 'Test User Agent',
    };

    it('should register a new user successfully', async () => {
      mockRateLimitService.checkLimit.mockResolvedValue(undefined);
      mockPrismaService.user.findUnique.mockResolvedValue(null);
      mockPasswordService.hashPassword.mockResolvedValue('hashed-password');
      mockPrismaService.user.create.mockResolvedValue({
        id: 'user-123',
        email: 'test@example.com',
      });
      mockPrismaService.verificationToken.create.mockResolvedValue(undefined);
      mockMailService.sendEmailVerification.mockResolvedValue(undefined);

      const result = await service.register(registerDto, deviceInfo);

      expect(result).toEqual({
        message: 'Registration successful. Please check your email for verification.',
        userId: 'user-123',
      });
      expect(mockPrismaService.user.create).toHaveBeenCalledWith({
        data: {
          email: 'test@example.com',
          password: 'hashed-password',
          firstName: 'John',
          lastName: 'Doe',
        },
      });
    });

    it('should throw ConflictException if user already exists', async () => {
      mockRateLimitService.checkLimit.mockResolvedValue(undefined);
      mockPrismaService.user.findUnique.mockResolvedValue({
        id: 'existing-user',
        email: 'test@example.com',
      });

      await expect(service.register(registerDto, deviceInfo)).rejects.toThrow(
        ConflictException,
      );
    });
  });

  describe('login', () => {
    const loginDto = {
      email: 'test@example.com',
      password: 'password123',
    };

    const deviceInfo = {
      deviceId: 'device-123',
      ipAddress: '127.0.0.1',
      userAgent: 'Test User Agent',
    };

    const mockUser = {
      id: 'user-123',
      email: 'test@example.com',
      password: 'hashed-password',
      role: 'USER',
      isActive: true,
    };

    it('should login user successfully', async () => {
      mockRateLimitService.checkLimit.mockResolvedValue(undefined);
      mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
      mockPasswordService.verifyPassword.mockResolvedValue(true);
      
      // Mock createUserSession private method behavior
      mockPrismaService.session.deleteMany.mockResolvedValue(undefined);
      mockTokenService.generateRefreshToken.mockResolvedValue('refresh-token');
      mockPasswordService.hashPassword.mockResolvedValue('hashed-refresh-token');
      mockPrismaService.session.create.mockResolvedValue({
        id: 'session-123',
        deviceId: 'device-123',
        expiresAt: new Date(),
      });
      mockTokenService.generateAccessToken.mockResolvedValue('access-token');

      const result = await service.login(loginDto, deviceInfo);

      expect(result).toHaveProperty('user');
      expect(result).toHaveProperty('tokens');
      expect(result).toHaveProperty('session');
      expect(mockPasswordService.verifyPassword).toHaveBeenCalledWith(
        'password123',
        'hashed-password',
      );
    });

    it('should throw UnauthorizedException for invalid credentials', async () => {
      mockRateLimitService.checkLimit.mockResolvedValue(undefined);
      mockPrismaService.user.findUnique.mockResolvedValue(null);

      await expect(service.login(loginDto, deviceInfo)).rejects.toThrow(
        UnauthorizedException,
      );
    });

    it('should throw UnauthorizedException for inactive user', async () => {
      mockRateLimitService.checkLimit.mockResolvedValue(undefined);
      mockPrismaService.user.findUnique.mockResolvedValue({
        ...mockUser,
        isActive: false,
      });
      mockPasswordService.verifyPassword.mockResolvedValue(true);

      await expect(service.login(loginDto, deviceInfo)).rejects.toThrow(
        UnauthorizedException,
      );
    });
  });

  describe('refreshTokens', () => {
    const refreshTokenDto = {
      refreshToken: 'valid-refresh-token',
    };

    const deviceInfo = {
      deviceId: 'device-123',
      ipAddress: '127.0.0.1',
    };

    const mockPayload = {
      sub: 'user-123',
      sessionId: 'session-123',
    };

    const mockSession = {
      id: 'session-123',
      userId: 'user-123',
      deviceId: 'device-123',
      refreshToken: 'hashed-refresh-token',
      expiresAt: new Date(Date.now() + 86400000), // Future date
      user: {
        id: 'user-123',
        email: 'test@example.com',
        role: 'USER',
      },
    };

    it('should refresh tokens successfully', async () => {
      mockTokenService.verifyRefreshToken.mockResolvedValue(mockPayload);
      mockPrismaService.session.findFirst.mockResolvedValue(mockSession);
      mockPasswordService.verifyPassword.mockResolvedValue(true);
      mockTokenService.generateRefreshToken.mockResolvedValue('new-refresh-token');
      mockTokenService.generateAccessToken.mockResolvedValue('new-access-token');
      mockPasswordService.hashPassword.mockResolvedValue('new-hashed-refresh-token');
      mockPrismaService.session.update.mockResolvedValue(undefined);

      const result = await service.refreshTokens(refreshTokenDto, deviceInfo);

      expect(result).toEqual({
        accessToken: 'new-access-token',
        refreshToken: 'new-refresh-token',
      });
      expect(mockTokenService.verifyRefreshToken).toHaveBeenCalledWith('valid-refresh-token');
    });

    it('should throw UnauthorizedException for invalid refresh token', async () => {
      mockTokenService.verifyRefreshToken.mockResolvedValue(mockPayload);
      mockPrismaService.session.findFirst.mockResolvedValue(mockSession);
      mockPasswordService.verifyPassword.mockResolvedValue(false);
      mockSessionsService.revokeAllUserSessions.mockResolvedValue(undefined);

      await expect(service.refreshTokens(refreshTokenDto, deviceInfo)).rejects.toThrow(
        UnauthorizedException,
      );
      expect(mockSessionsService.revokeAllUserSessions).toHaveBeenCalledWith('user-123');
    });
  });

  describe('logout', () => {
    it('should logout successfully', async () => {
      mockSessionsService.revokeSession.mockResolvedValue(undefined);

      const result = await service.logout('user-123', 'device-123');

      expect(result).toEqual({ message: 'Logged out successfully' });
      expect(mockSessionsService.revokeSession).toHaveBeenCalledWith('user-123', 'device-123');
    });
  });

  describe('resetPassword', () => {
    const resetPasswordDto = {
      token: 'valid-reset-token',
      newPassword: 'newpassword123',
    };

    const mockResetToken = {
      token: 'valid-reset-token',
      userId: 'user-123',
      usedAt: null,
      expiresAt: new Date(Date.now() + 900000), // Future date
      user: { id: 'user-123' },
    };

    it('should reset password successfully', async () => {
      mockPrismaService.passwordResetToken.findUnique.mockResolvedValue(mockResetToken);
      mockPasswordService.hashPassword.mockResolvedValue('new-hashed-password');
      mockPrismaService.$transaction.mockResolvedValue(undefined);

      const result = await service.resetPassword(resetPasswordDto);

      expect(result).toEqual({ message: 'Password reset successfully' });
      expect(mockPasswordService.hashPassword).toHaveBeenCalledWith('newpassword123');
    });
  });
});

// src/auth/services/password.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { PasswordService } from './password.service';
import * as argon2 from 'argon2';

jest.mock('argon2');

describe('PasswordService', () => {
  let service: PasswordService;
  const mockedArgon2 = argon2 as jest.Mocked<typeof argon2>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [PasswordService],
    }).compile();

    service = module.get<PasswordService>(PasswordService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('hashPassword', () => {
    it('should hash password successfully', async () => {
      const password = 'password123';
      const hashedPassword = 'hashed-password';
      
      mockedArgon2.hash.mockResolvedValue(hashedPassword);

      const result = await service.hashPassword(password);

      expect(result).toBe(hashedPassword);
      expect(mockedArgon2.hash).toHaveBeenCalledWith(password);
    });
  });

  describe('verifyPassword', () => {
    it('should verify password successfully', async () => {
      const password = 'password123';
      const hashedPassword = 'hashed-password';
      
      mockedArgon2.verify.mockResolvedValue(true);

      const result = await service.verifyPassword(password, hashedPassword);

      expect(result).toBe(true);
      expect(mockedArgon2.verify).toHaveBeenCalledWith(hashedPassword, password);
    });

    it('should return false for invalid password', async () => {
      const password = 'wrongpassword';
      const hashedPassword = 'hashed-password';
      
      mockedArgon2.verify.mockResolvedValue(false);

      const result = await service.verifyPassword(password, hashedPassword);

      expect(result).toBe(false);
    });
  });
});

// src/auth/services/token.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { ConfigService } from '@nestjs/config';
import { JwtService } from '@nestjs/jwt';
import { TokenService } from './token.service';

describe('TokenService', () => {
  let service: TokenService;
  let jwtService: JwtService;
  let configService: ConfigService;

  const mockJwtService = {
    sign: jest.fn(),
    verify: jest.fn(),
  };

  const mockConfigService = {
    get: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TokenService,
        {
          provide: JwtService,
          useValue: mockJwtService,
        },
        {
          provide: ConfigService,
          useValue: mockConfigService,
        },
      ],
    }).compile();

    service = module.get<TokenService>(TokenService);
    jwtService = module.get<JwtService>(JwtService);
    configService = module.get<ConfigService>(ConfigService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('generateAccessToken', () => {
    it('should generate access token', async () => {
      const payload = {
        sub: 'user-123',
        email: 'test@example.com',
        role: 'USER',
        sessionId: 'session-123',
        deviceId: 'device-123',
      };

      mockConfigService.get.mockImplementation((key) => {
        if (key === 'jwt.accessSecret') return 'access-secret';
        if (key === 'jwt.accessExpiresIn') return '15m';
      });

      mockJwtService.sign.mockReturnValue('access-token');

      const result = await service.generateAccessToken(payload);

      expect(result).toBe('access-token');
      expect(mockJwtService.sign).toHaveBeenCalledWith(payload, {
        secret: 'access-secret',
        expiresIn: '15m',
      });
    });
  });

  describe('generateRefreshToken', () => {
    it('should generate refresh token', async () => {
      const expectedToken = 'refresh-token-123';
      jest.spyOn(service, 'generateRefreshToken').mockResolvedValue(expectedToken);

      const result = await service.generateRefreshToken();

      expect(result).toBe(expectedToken);
      expect(typeof result).toBe('string');
      expect(result.length).toBeGreaterThan(0);
    });
  });

  describe('verifyRefreshToken', () => {
    it('should verify refresh token successfully', async () => {
      const token = 'valid-refresh-token';
      const payload = { sub: 'user-123', sessionId: 'session-123' };

      mockConfigService.get.mockReturnValue('refresh-secret');
      mockJwtService.verify.mockReturnValue(payload);

      const result = await service.verifyRefreshToken(token);

      expect(result).toEqual(payload);
      expect(mockJwtService.verify).toHaveBeenCalledWith(token, {
        secret: 'refresh-secret',
      });
    });
  });
});

// src/users/users.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { ConflictException, NotFoundException } from '@nestjs/common';
import { UsersService } from './users.service';
import { PrismaService } from '../prisma/prisma.service';
import { PasswordService } from '../auth/services/password.service';

describe('UsersService', () => {
  let service: UsersService;
  let prismaService: PrismaService;
  let passwordService: PasswordService;

  const mockPrismaService = {
    user: {
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      findMany: jest.fn(),
      count: jest.fn(),
    },
    session: {
      deleteMany: jest.fn(),
    },
    oAuthAccount: {
      findMany: jest.fn(),
      delete: jest.fn(),
    },
  };

  const mockPasswordService = {
    verifyPassword: jest.fn(),
    hashPassword: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UsersService,
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
        {
          provide: PasswordService,
          useValue: mockPasswordService,
        },
      ],
    }).compile();

    service = module.get<UsersService>(UsersService);
    prismaService = module.get<PrismaService>(PrismaService);
    passwordService = module.get<PasswordService>(PasswordService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('findById', () => {
    it('should return user without password', async () => {
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        firstName: 'John',
        lastName: 'Doe',
        role: 'USER',
        isActive: true,
        isTwoFactorEnabled: false,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      mockPrismaService.user.findUnique.mockResolvedValue(mockUser);

      const result = await service.findById('user-123');

      expect(result).toEqual(mockUser);
      expect(mockPrismaService.user.findUnique).toHaveBeenCalledWith({
        where: { id: 'user-123' },
        select: expect.objectContaining({
          id: true,
          email: true,
          password: false, // Should exclude password
        }),
      });
    });

    it('should return null if user not found', async () => {
      mockPrismaService.user.findUnique.mockResolvedValue(null);

      const result = await service.findById('non-existent');

      expect(result).toBeNull();
    });
  });

  describe('updateProfile', () => {
    const updateDto = {
      firstName: 'Jane',
      lastName: 'Smith',
      email: 'jane@example.com',
    };

    it('should update user profile successfully', async () => {
      const updatedUser = {
        id: 'user-123',
        ...updateDto,
        role: 'USER',
        isActive: true,
        isTwoFactorEnabled: false,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      mockPrismaService.user.findUnique.mockResolvedValue(null); // No existing user with new email
      mockPrismaService.user.update.mockResolvedValue(updatedUser);

      const result = await service.updateProfile('user-123', updateDto);

      expect(result).toEqual(updatedUser);
      expect(mockPrismaService.user.update).toHaveBeenCalledWith({
        where: { id: 'user-123' },
        data: expect.objectContaining({
          ...updateDto,
          emailVerified: null, // Should reset email verification
        }),
        select: expect.any(Object),
      });
    });

    it('should throw ConflictException if email is already taken', async () => {
      mockPrismaService.user.findUnique.mockResolvedValue({
        id: 'different-user-id',
        email: 'jane@example.com',
      });

      await expect(
        service.updateProfile('user-123', updateDto),
      ).rejects.toThrow(ConflictException);
    });
  });

  describe('changePassword', () => {
    const changePasswordDto = {
      currentPassword: 'oldpassword',
      newPassword: 'newpassword123',
    };

    it('should change password successfully', async () => {
      const mockUser = {
        id: 'user-123',
        password: 'hashed-old-password',
      };

      mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
      mockPasswordService.verifyPassword.mockResolvedValue(true);
      mockPasswordService.hashPassword.mockResolvedValue('hashed-new-password');
      mockPrismaService.user.update.mockResolvedValue(undefined);
      mockPrismaService.session.deleteMany.mockResolvedValue({ count: 2 });

      const result = await service.changePassword('user-123', changePasswordDto);

      expect(result).toEqual({ message: 'Password changed successfully' });
      expect(mockPasswordService.verifyPassword).toHaveBeenCalledWith(
        'oldpassword',
        'hashed-old-password',
      );
      expect(mockPasswordService.hashPassword).toHaveBeenCalledWith('newpassword123');
    });

    it('should throw NotFoundException if user not found', async () => {
      mockPrismaService.user.findUnique.mockResolvedValue(null);

      await expect(
        service.changePassword('non-existent', changePasswordDto),
      ).rejects.toThrow(NotFoundException);
    });
  });

  describe('deleteAccount', () => {
    it('should delete user account successfully', async () => {
      mockPrismaService.user.delete.mockResolvedValue(undefined);

      const result = await service.deleteAccount('user-123');

      expect(result).toEqual({ message: 'Account deleted successfully' });
      expect(mockPrismaService.user.delete).toHaveBeenCalledWith({
        where: { id: 'user-123' },
      });
    });
  });
});